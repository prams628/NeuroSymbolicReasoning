import argparse
import base64
import os
import time

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait

class Constants:
    """
    Some constants are being initialised
    """
    GENERATE_BUTTON_XPATH = '/html/body/div/div[2]/div[1]/input[8]'
    CANVAS_XPATH = '/html/body/div/div[2]/div[4]/canvas'
    SLEEP_TIME = 10
    DIFFICULTY_XPATHS = {
        'easy': '/html/body/div/div[2]/div[1]/input[3]',
        'medium': '/html/body/div/div[2]/div[1]/input[4]',
        'hard': '/html/body/div/div[2]/div[1]/input[5]'
    }
    WIDTH_TEXT_XPATH = '/html/body/div/div[2]/div[1]/input[1]'
    HEIGHT_TEXT_XPATH = '/html/body/div/div[2]/div[1]/input[2]'


class FetchDataError(Exception):
    '''
    A custom error class to track errors raised in the process of fetching the data
    '''
    pass


def get_driver(headless=False):
    """
    Initialises a webdriver object for chrome
    :return: webdriver
    """
    options = webdriver.ChromeOptions()
    if headless:
        options.add_argument('--headless')
    driver = webdriver.Chrome(options=options)
    return driver


def generate_data(driver: webdriver, difficulty: str, number_of_instances: int, folder: str,
                  width: str, height: str):
    """
    This function orchestrates the procedure of generating the data. The procedure can be summarised as follows:
        1. Iterate the data generation loop for the number of instances specified.
        2. Generate the button to generate a new puzzle
        3. Wait for a few seconds
        4. Take a screenshot as base64 and save as PNG.
    :param driver: The webdriver object to communicate with tfile_pathhe website and generate data
    :param number_of_instances: Number of data points which are to be generated by the function
    :param folder: the folder which should contain data after generation
    :return: None
    """
    # fetch the page
    driver.get('https://www.kakuro-online.com/generator')

    # set the difficulty of the puzzle
    difficulty_radio_button = driver.find_element(
        By.XPATH, Constants.DIFFICULTY_XPATHS[difficulty]
    )
    difficulty_radio_button.click()

    width_element = driver.find_element(By.XPATH, Constants.WIDTH_TEXT_XPATH)
    width_element.clear()
    width_element.send_keys(width)

    height_element = driver.find_element(By.XPATH, Constants.HEIGHT_TEXT_XPATH)
    height_element.clear()
    height_element.send_keys(height)

    if not os.path.exists(folder):
        os.mkdir(folder)

    # init a web driver wait object
    _ = WebDriverWait(driver, Constants.SLEEP_TIME).\
            until(EC.presence_of_element_located((
                By.XPATH, Constants.GENERATE_BUTTON_XPATH
            )))

    start_idx = len(os.listdir(folder))
    for idx in range(start_idx, start_idx + number_of_instances):
        # get the button to generate a new puzzle
        generate_button = driver.find_element(By.XPATH, Constants.GENERATE_BUTTON_XPATH)
        generate_button.click()

        # Giving the website time to load up the puzzle
        time.sleep(Constants.SLEEP_TIME)

        # XPath of the canvas containing the puzzle
        canvas = driver.find_element(By.XPATH, Constants.CANVAS_XPATH)
        screenshot = canvas.screenshot_as_base64

        # decode and write the contents to the file
        decoded = base64.b64decode(screenshot)
        dest_path = os.path.join(folder, f'puzzle_{idx}.png')
        with open(dest_path, 'wb') as f:
            f.write(decoded)

        if (idx + 1) % 10 == 0:
            print(f'{idx} instances generated')


def close_driver(driver: webdriver):
    """
    This function closes the driver which has been opened by the get_driver function.
    :param driver: A selenium webdriver
    :return: None
    """
    driver.close()


# now begins the main part
parser = argparse.ArgumentParser()
basic = parser.add_argument_group('basic')
basic.add_argument('-c', '--count', help='Number of data points which are to be generated', type=int)
basic.add_argument('-d', '--difficulty', help='Difficulty of the problem to be extracted', default='easy')

split = parser.add_argument_group('split')
split.add_argument('-e', '--easy', help='Number of easy samples to fetch', default=0, type=int)
split.add_argument('-m', '--medium', help='Number of medium samples to fetch', default=0, type=int)
split.add_argument('-a', '--hard', help='Number of hard samples to fetch', default=0, type=int)

parser.add_argument('-w', '--width', help='The width of the puzzle to be generated', default='9')
parser.add_argument('-H', '--height', help='The height of the puzzle to be generated', default='9')
parser.add_argument('--headless', help='Add this parameter if you wish to not open a chrome window'
                    'to always remain in focus during data generation.', action='store_true')

# parse the arguments supplied
args = parser.parse_args()
data_folder = '../data/puzzles/'
webdriver = get_driver(args.headless)

try:
    if args.count:
        generate_data(webdriver, args.difficulty, args.count, os.path.join(data_folder, args.difficulty), args.width, args.height)
    elif args.easy or args.medium or args.hard:
        generate_data(webdriver, 'easy', args.easy, os.path.join(data_folder, 'easy'), args.width, args.height)
        generate_data(webdriver, 'medium', args.medium, os.path.join(data_folder, 'medium'), args.width, args.height)
        generate_data(webdriver, 'hard', args.hard, os.path.join(data_folder, 'hard'), args.width, args.height)
    else:
        print('Argument count has to be supplied')
        raise FetchDataError
except FetchDataError as fde:
    close_driver(webdriver)
    raise fde
finally:
    pass

close_driver(webdriver)